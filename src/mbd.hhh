#ifndef MBD_H
#define MBD_H

#include "timestep.h"
#include "group.h"
#include "atom.h"
#include <vector>
#include <fstream>

#define MBD_TYPE_CONSTANT 1
#define MBD_TYPE_GAUSSIAN 2

using namespace std;


//class MBD;
class Distribution;
class BondDistribution;

class Distribution {
public:
    Distribution() :mMin(0),mMax(1),mResolution(0.1) { mValues.resize(11, 0); mTotalCount=0; }
    Distribution(float, float, float);
    Distribution(float, float, vector<float> &); //read in values from vector<int>&
    void setMin(float a) {mMin=a;}
    void setMax(float a) {mMax=a;}
    void setResolution(float a) {mResolution=a;}
    void setValues(vector<float> &a);
    void setTotalCount(float a) {mTotalCount=a;}
    float getMin() const {return mMin;}
    float getMax() const {return mMax;}
    float getResolution() const {return mResolution;}
    int getTotalCount() const {return mTotalCount;}
    int getCount(float) const; //get the count for a given bond length
    int getCount(float, float) const; //get the count for a range of bond lengths
    float getCountNormalized(float) const; //normalized value (divided by total number of added bonds)
    float getCountNormalized(float, float) const; //get the count for a range of bond lengths
    bool addBond(float); //add a bond to the member vector. return true if the given value is in the allowed range.
    void print(ofstream*, Timestep *, bool paverage=false, bool pnormalize=false, bool pprintdistribution=false) const;
    void normalize(); //this will irreversibly normalize all the values in mValues by mTotalCount!
    vector<float> mValues;
private:
    float mMin;
    float mMax;
    float mResolution; 
    float mTotalCount; //should be integer unless normalized values are done
};


class BondDistribution : public Distribution {
public:
    BondDistribution(float pmin=0.0, float pmax=1.0, float presolution=0.1, Group *panchorgroup=nullptr, Group *ptargetgroup=nullptr) :Distribution(pmin,pmax,presolution), mAnchorGroup(panchorgroup), mTargetGroup(ptargetgroup) { }
    //BondDistribution::addPlenty(vector<Atom*> *anchoratoms, vector<Atom*> *targetatoms);
    void addPlenty();
    Group *mAnchorGroup;
    Group *mTargetGroup;
};

class ModifyBondDistribution {
public:
    //ModifyBondDistribution(BondDistribution*, string, string, int ptargettype, float pparam1, float pparam2 = 0.0);
    ModifyBondDistribution(BondDistribution*, ifstream*, ofstream*, string, int ptargettype, float pparam1, float pparam2=0.0);
    ModifyBondDistribution(BondDistribution *pbonddistribution, BondDistribution *ptargetbonddistribution);
    BondDistribution *mBondDistribution;
    string mFramesToModifyFileName;
    string mFramesToModifyFileFormat;
    void doIt();
    void setTargetDistribution();
private:
    //void readFramesToModify(string pfilename);
    BondDistribution mTargetBondDistribution;
    int mTargetType;
    float mTargetParam1;
    float mTargetParam2;
    ifstream *mInStructs;
    ofstream *mOutStructs;
    string mFormat;
};


#endif
